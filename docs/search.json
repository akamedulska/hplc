[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RP-HPLC",
    "section": "",
    "text": "A comparison of the two series of columns can be found on the website: https://www.waters.com/nextgen/us/en/products/columns/compare-columns.html?productname=xbridge-columns%2Cxterra-columns.\nData of the 300 small molecules from the XBrigde Shield C18 and XTerra C18 columns are generally available at the following links: XBridge Shield C18 and XTerra C18.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAll analytes:"
  },
  {
    "objectID": "Model_1.html",
    "href": "Model_1.html",
    "title": "Model 1",
    "section": "",
    "text": "This model was described in the article: “Toward the general mechanistic model of liquid chromatographic retention” (link to the model description on github https://akamedulska.github.io/lc-ms/script.html)."
  },
  {
    "objectID": "Model_1_a.html",
    "href": "Model_1_a.html",
    "title": "1  Stan code",
    "section": "",
    "text": "functions {\n\n// credit http://srmart.in/informative-priors-for-correlation-matrices-an-easy-approach/\nvector lower_tri(matrix mat) {\n\nint d = rows(mat);\nint lower_tri_d = d * (d - 1) / 2;\nvector[lower_tri_d] lower;\nint count = 1;\nfor(r in 2:d) {\nfor(c in 1:(r - 1)) {\nlower[count] = mat[r,c];\ncount += 1;\n}\n}\nreturn(lower); \n}\n\n// credit http://srmart.in/informative-priors-for-correlation-matrices-an-easy-approach/\nreal lkj_corr_point_lower_tri_lpdf(matrix rho, vector point_mu_lower, vector point_scale_lower) {\n\nreal lpdf = lkj_corr_lpdf(rho | 1) + normal_lpdf(lower_tri(rho) | point_mu_lower, point_scale_lower);\nreturn(lpdf);\n}\n\n\nreal lkj_corr_cholesky_point_lower_tri_two_lpdf(matrix cor_L, real point_mu_lower, real point_scale_lower) {\n    real lpdf = lkj_corr_cholesky_lpdf(cor_L | 1);\n    int d = rows(cor_L);\n    matrix[d,d] cor = multiply_lower_tri_self_transpose(cor_L);\n    lpdf += normal_lpdf(cor[2,1] | point_mu_lower, point_scale_lower);\n    return(lpdf);\n  }\n\n// pH and fi at a given time at column inlet\nvector gra_state(real t,  vector hplcparam) {\n\nvector[2] sol;\nreal tg = hplcparam[1];\nreal td = hplcparam[2];\nreal fio = hplcparam[5];\nreal fik = hplcparam[6];\nreal pHo = hplcparam[8];\nreal alpha1 = hplcparam[9];\nreal alpha2 = hplcparam[10];\nreal fi;\n\nfi = fio+(fik-fio)/tg*(t-td);\n\nif (t<td)\nfi = fio;\nelse if (t>tg+td)\nfi = fik;\n\nsol[1]=fi;\nsol[2]=pHo+alpha1*fi+alpha2*fi^2;\n\nreturn sol;\n}\n\nreal funlogki(vector logkwx, vector S1, vector pKaw, vector alpha, real S2, vector apH,\n              int nDiss, vector chargesA, vector chargesB, vector fipH) {\n\nreal logki;\nvector[3] logkix;\nvector[2] pHmpKa;\nreal fi=fipH[1];\nreal pH=fipH[2];\n\nlogkix=logkwx-S1*fi/(1+S2*fi)+ chargesA*apH[1]*(pH-7) + chargesB*apH[2]*(pH-7);\npHmpKa=pH-(pKaw+alpha*fi);\n\nif (nDiss==0) {\n    logki = logkix[1]; \n}\nelse if (nDiss==1){\n    logki=logkix[1] +\n    log1p_exp(log(10)*(pHmpKa[1]+logkix[2]-logkix[1]))/log(10)-\n    log1p_exp(log(10)*(pHmpKa[1]))/log(10);\n}\nelse if (nDiss==2){\n    logki = logkix[1] +\n    log1p_exp(log(10)*(pHmpKa[1]+logkix[2]-logkix[1]) + \n    log1p_exp(log(10)*(pHmpKa[2]+logkix[3]-logkix[2])))/log(10)-\n    log1p_exp(log(10)*(pHmpKa[1]) + \n    log1p_exp(log(10)*(pHmpKa[2])))/log(10);\n}\n\nreturn logki;\n}\n\nvector areaandslope(real time1, real time2, real invki1, real invki2) {\n\nvector[2] cki_b;\nreal bo;\nreal cki;\n\nif (invki2>1.001*invki1) {\n    bo = (log(invki2)-log(invki1))/(time2-time1);\n    cki = (invki2-invki1)/bo;\n}\nelse {\n    bo  = 0.001/(time2-time1);\n    cki = (time2-time1)*(invki2+invki1)/2;\n}\n\ncki_b[1] = cki;\ncki_b[2] = bo;\n\nreturn cki_b;\n}\n\nreal chromgratrapz(int steps, \n           vector logkwx, vector logkmx, vector pKaw, vector alpha,\n           real S2, vector apH, vector chargesA, vector chargesB,\n           int nDiss, vector hplcparam) {\n\nreal tg = hplcparam[1];\nreal td = hplcparam[2];\nreal to = hplcparam[3];\n\nvector[1] sol;\nreal time1;\nreal time2; \nvector[2] fipH1;\nvector[2] fipH2;\nreal logki1;\nreal logki2; \nreal invki1;\nreal invki2;\nvector[2] cki_b;\nreal cumki1;\nreal cumki2;\nreal bo;\nreal tr;\nreal dt;\n\ndt = tg/steps;\n\ntime1 = 0;\ntime2 = td;\n\nfipH1 = gra_state(time1,  hplcparam);\n// fipH2 = fipH1;\n\nlogki1 = funlogki(logkwx, logkmx, pKaw, alpha, S2, apH, nDiss, chargesA, chargesB, fipH1);\n//logki2 = logki1;\n\ninvki1 = 1/to/10^logki1;\ninvki2 = invki1;\n\ncumki1 = 0;\ncumki2 = td*invki1; // cumulative area\n\nbo     = 0.001/td;  // slope\n\nfor(x in 1:steps){ \n    if (cumki2>=1)  continue;\n    time1 = time2;\n    time2 += dt;\n//    fipH1 = fipH2;\n    fipH2 = gra_state(time2,  hplcparam);\n//    logki1 = logki2;\n    logki2 = funlogki(logkwx, logkmx, pKaw, alpha, S2, apH, nDiss, chargesA, chargesB, fipH2);\n    invki1 = invki2;\n    invki2 = 1/to/10^logki2;\n    cki_b = areaandslope(time1, time2, invki1, invki2);\n    cumki1 = cumki2;\n    cumki2 += cki_b[1]; // cumulative area\n    bo      = cki_b[2]; //slope\n}\n\nif (cumki2>=1) {\n    tr = time1+log1p((1-cumki1)*bo/invki1)/bo;\n}\nelse if (cumki2<1) {\n    tr = time2+(1-cumki2)/invki2;\n}\n\nreturn tr;\n}\n\nreal partial_sum(int[] ind, int start, int end, vector trObs, \nint[] mod, int[] steps, int[] analyte, int[] pHid,\nvector[] hplcparam, vector[] chargesA, vector[] chargesB, int[] nDiss,\nvector[] logkwx, vector dlogkT, vector[] S1mx, vector[] S1ax,\nvector[] pKaw, vector[] alpham, vector[] alphaa,\nreal S2m, real S2a,\nvector apH,\nvector sigma) {\n\nreal lp = 0;\nreal y_hat;\n\nfor(z in start:end){\n\nif (mod[z]==1) {\ny_hat = chromgratrapz(steps[z], \n       logkwx[analyte[z],] + dlogkT[analyte[z]]*hplcparam[z,11], \n       S1mx[analyte[z],],  \n       pKaw[analyte[z],], \n       alpham[analyte[z],],\n       S2m,\n       apH,\n       chargesA[analyte[z],], \n       chargesB[analyte[z],], \n       nDiss[analyte[z]],\n       hplcparam[z]);\n }\n\nif (mod[z]==2) {\ny_hat = chromgratrapz(steps[z], \n       logkwx[analyte[z],]  + dlogkT[analyte[z]]*hplcparam[z,11], \n       S1ax[analyte[z],],  \n       pKaw[analyte[z],], \n       alphaa[analyte[z],],\n       S2a,\n       apH,\n       chargesA[analyte[z],],\n       chargesB[analyte[z],], \n       nDiss[analyte[z]],\n       hplcparam[z]);\n}\n\n  real trHat = hplcparam[z,3] + hplcparam[z,4] + y_hat; \n\n  lp = lp + student_t_lpdf(trObs[z] | 3, trHat, sigma[analyte[z]]);\n\n }\n return lp;\n}\n}\n\ndata{\nint nAnalytes;             // number of analytes\nint nObs;                  // number of observations\nint npH;                   // npH;\nint analyte[nObs];         // analyte indexes\nint pHid[nObs];\nint<lower=1> steps[nObs];   // steps for gradient retention time aproimation\nvector[11] hplcparam[nObs]; // [tg, td, to, te, fio, fik, mod, pHo, alpha1, alpha2, (temp-25)/10]\nint<lower=0> mod[nObs];     // MeOH==1, ACN==2 (repeats hplcparam(:,7))\n\nvector[nAnalytes] logPobs; \n\nint<lower=0,upper=2> maxR;\nint<lower=0,upper=2> R[nAnalytes];\nordered[maxR] pKaslit[nAnalytes];\nvector[maxR] pKasliterror[nAnalytes];\nvector[maxR] groupsA[nAnalytes];\nvector[maxR] groupsB[nAnalytes];\nvector[maxR+1] chargesA[nAnalytes];\nvector[maxR+1] chargesB[nAnalytes];\n\nint<lower=0> K;                      //  number of predictors (functional groups)\nmatrix[nAnalytes, K] nrfungroups;   // predictor matrix (functional groups)   \n\nvector[nObs] trobs; // observed retention factors \n\n}\n\ntransformed data {\nint grainsize = 1;\nint ind[nObs] = rep_array(1, nObs);\nvector[3] point_mu_lower = [0.75,0.75,0.75]';       // mean priors for rho\nvector[3] point_scale_lower = [0.125,0.125,0.125]'; // std priors for rho\n}\n\nparameters{\nreal logkwHat;         // typical value of logkw [N]\nreal S1mHat;           // typical value of S1m [N]\nreal S1aHat;           // typical value of S1a [N]\nreal dlogkwHat[2];     // typical value of dlogkw [A,B] \nreal dSmHat[2];        // typical value of dlogkm [A,B] \nreal dSaHat[2];        // typical value of dlogka [A,B] \nreal<lower = 0> S2mHat; // typical value of S2m \nreal<lower = 0> S2aHat; // typical value of S2a\nvector[3] beta;         // effects of logP \nreal dlogkTHat;         // typical dlogkT\nvector[2] alphaAHat;  // changes of pKa with org. mod for acids [MeOH, ACN]\nvector[2] alphaBHat;  // changes of pKa with org. mod for bases [MeOH, ACN]\n\nvector<lower = 0.01>[3] omega;   // between analyte variabilities (neutral forms)\ncorr_matrix[3] rho1;                            // correlation matrix    \nvector<lower = 0.01>[3] kappa;    // between analyte variabilities (diss. forms)\nvector<lower = 0.01>[2] tau;     // between analyte variabilities for acids pKa\ncholesky_factor_corr[2] L2;                         // cholesky \nreal<lower = 0.01, upper = 1> omegadlogkT;  // between analyte variability for temperature\n\n// between buffer differences\nvector[2] apH; // pH effects\n\nvector[K] pilogkw;  // regression coefficient for logkw\nvector[K] piS1m;  // regression coefficient for S1m\nvector[K] piS1a;  // regression coefficient for S1a\n\nvector<lower = 0.01>[3] sdpi;     // between analyte variabilities for acids pKa\n\n// residual variability\nreal<lower = 0.01> msigma; // mean\nreal<lower = 0.01> ssigma; // scale\n\n// individual values of chromatographic parameters\nvector[3] param[nAnalytes]; \nvector[nAnalytes] dlogkT;   \nmatrix[nAnalytes,maxR+1] dlogkwA;\nmatrix[nAnalytes,maxR+1] dlogkwB;\nmatrix[nAnalytes,maxR+1] dSmA;\nmatrix[nAnalytes,maxR+1] dSmB;\nmatrix[nAnalytes,maxR+1] dSaA;\nmatrix[nAnalytes,maxR+1] dSaB;\n\nvector[maxR] pKaw[nAnalytes];\nmatrix[maxR,nAnalytes] etaStd1;\nmatrix[maxR,nAnalytes] etaStd2;\n\n// and residuals\nvector<lower = 0.01, upper = 4>[nAnalytes] sigma;\n}\n\ntransformed parameters{\nvector[maxR+1] logkwx[nAnalytes];\nvector[maxR+1] S1mx[nAnalytes];\nvector[maxR+1] S1ax[nAnalytes];\nmatrix[nAnalytes,maxR] alpha1;   //MeOH or ACN\nmatrix[nAnalytes,maxR] alpha2;   //MeOH or ACN\n\nvector[maxR] alpham[nAnalytes];\nvector[maxR] alphaa[nAnalytes];\n\nvector[3] miu[nAnalytes];   \ncov_matrix[3] Omega; // variance-covariance matrix\n\nOmega = quad_form_diag(rho1, omega);    // diag_matrix(omega) * rho * diag_matrix(omega)\n\n\n// Matt's trick to use unit scale \n alpha1 = diag_pre_multiply(tau, L2 * etaStd1)';\n alpha2 = diag_pre_multiply(tau, L2 * etaStd2)';\n\n\nfor(i in 1:nAnalytes){\n    miu[i,1]  = logkwHat + beta[1] * (logPobs[i]-2.2) + nrfungroups[i] * pilogkw;\n    miu[i,2]  = S1mHat   + beta[2] * (logPobs[i]-2.2) + nrfungroups[i] * piS1m; \n    miu[i,3]  = S1aHat   + beta[3] * (logPobs[i]-2.2) + nrfungroups[i] * piS1a;\n}\n\nfor(i in 1:nAnalytes){\nfor(r in 1:maxR+1){\nlogkwx[i,r] = param[i, 1] +\n            dlogkwA[i,r]*chargesA[i,r] +\n            dlogkwB[i,r]*chargesB[i,r];\nS1mx[i,r] = (param[i, 2] + \n            dSmA[i,r]*chargesA[i,r] +\n            dSmB[i,r]*chargesB[i,r])*(1+S2mHat);\nS1ax[i,r] = (param[i, 3] + \n            dSaA[i,r]*chargesA[i,r] +\n            dSaB[i,r]*chargesB[i,r])*(1+S2aHat);\n\n}}\n\nfor(i in 1:nAnalytes){\nalpham[i,1] = (alphaAHat[1]+alpha1[i,1]) * groupsA[i,1] + (alphaBHat[1]+alpha1[i,1]) * groupsB[i,1];\nalpham[i,2] = (alphaAHat[1]+alpha2[i,1]) * groupsA[i,2] + (alphaBHat[1]+alpha2[i,1]) * groupsB[i,2];\n\nalphaa[i,1] = (alphaAHat[2]+alpha1[i,2]) * groupsA[i,1] + (alphaBHat[2]+alpha1[i,2]) * groupsB[i,1];\nalphaa[i,2] = (alphaAHat[2]+alpha2[i,2]) * groupsA[i,2] + (alphaBHat[2]+alpha2[i,2]) * groupsB[i,2];\n}\n\n}\nmodel{\nlogkwHat  ~ normal(2.2, 2);\nS1mHat    ~ normal(4, 1);\nS1aHat    ~ normal(5, 1);\ndlogkwHat ~ normal(-1,0.125);\ndSmHat    ~ normal(0,0.5);\ndSaHat    ~ normal(0,0.5);\nS2mHat    ~ lognormal(-1.6,0.125);\nS2aHat    ~ lognormal(0.69,0.125);\nalphaAHat ~ normal(2,0.25);\nalphaBHat ~ normal(-1,0.25);\nbeta[{1}] ~ normal(1,0.125);\nbeta[{2,3}] ~ normal(0.5,0.5);\nomega       ~ normal(0,2);\nrho1         ~ lkj_corr_point_lower_tri(point_mu_lower, point_scale_lower);\nkappa       ~ normal(0,0.5);\n\napH ~ normal(0,0.1);\n\npilogkw ~ normal(0,sdpi[1]);\npiS1m   ~ normal(0,sdpi[2]);\npiS1a   ~ normal(0,sdpi[3]);\n\nsdpi ~ normal(0,0.1);\n\ntau ~ normal(0,0.5);\nL2 ~ lkj_corr_cholesky_point_lower_tri_two(0.75, 0.125);\n\ndlogkTHat   ~ normal(-0.087,0.022);\nomegadlogkT ~ normal(0,0.022);\n\nsigma  ~ lognormal(log(msigma),ssigma); \nmsigma ~ normal(0,1);\nssigma ~ normal(0,1);\n\nfor(i in  1:nAnalytes){\nparam[i] ~ multi_normal(miu[i],Omega);\n}\n\nto_vector(dlogkwA) ~ normal(dlogkwHat[1],kappa[1]);\nto_vector(dlogkwB) ~ normal(dlogkwHat[2],kappa[1]);\nto_vector(dSmA) ~ normal(dSmHat[1],kappa[2]);\nto_vector(dSmB) ~ normal(dSmHat[2],kappa[2]);\nto_vector(dSaA) ~ normal(dSaHat[1],kappa[3]);\nto_vector(dSaB) ~ normal(dSaHat[2],kappa[3]);\n\nto_vector(etaStd1) ~ std_normal();\nto_vector(etaStd2) ~ std_normal();\n\ndlogkT  ~ normal(dlogkTHat,omegadlogkT);\n\nfor (i in 1:nAnalytes) pKaw[i] ~ normal(pKaslit[i],pKasliterror[i]);\n\ntarget += reduce_sum(partial_sum, ind, grainsize, trobs, \n        mod, steps, analyte, pHid, hplcparam, chargesA, chargesB, R,\n        logkwx, dlogkT, S1mx, S1ax,\n        pKaw, alpham, alphaa,\n        S2mHat, S2aHat,\n        apH, sigma);\n}\n\ngenerated quantities{\nreal trCond[nObs];\nreal trPred[nObs];\nreal y_hat_Cond;\nreal y_hat_Pred;\nvector[3] paramPred[nAnalytes]; \nmatrix[nAnalytes,maxR+1] dlogkwAPred;\nmatrix[nAnalytes,maxR+1] dlogkwBPred;\nmatrix[nAnalytes,maxR+1] dSmAPred;\nmatrix[nAnalytes,maxR+1] dSmBPred;\nmatrix[nAnalytes,maxR+1] dSaAPred;\nmatrix[nAnalytes,maxR+1] dSaBPred;\nvector[nAnalytes] dlogkTPred;\nvector[maxR+1] logkwxPred[nAnalytes];\nvector[maxR+1] S1mxPred[nAnalytes];\nvector[maxR+1] S1axPred[nAnalytes];\nvector[maxR] pKawPred[nAnalytes];\nvector[nAnalytes] sigmaPred; \nmatrix[maxR,nAnalytes]  etaStd1Pred;\nmatrix[maxR,nAnalytes]  etaStd2Pred;\nmatrix[nAnalytes,maxR] alpha1Pred; \nmatrix[nAnalytes,maxR] alpha2Pred; \nvector[maxR] alphamPred[nAnalytes];\nvector[maxR] alphaaPred[nAnalytes];\n\ncorr_matrix[2] rho2;\n \nrho2 = L2 * L2';\n  \nfor(i in 1:nAnalytes){\ndlogkTPred[i] = normal_rng(dlogkTHat,omegadlogkT); \nsigmaPred[i] = lognormal_rng(log(msigma), ssigma);\n}\n\nfor(i in 1:nAnalytes){\nparamPred[i] = multi_normal_rng(miu[i],Omega);\n}\n\nfor(r in 1:(maxR+1)){ \nfor(i in 1:nAnalytes){\ndlogkwAPred[i, r] = normal_rng(dlogkwHat[1],kappa[1]);\ndlogkwBPred[i, r] = normal_rng(dlogkwHat[2],kappa[1]);\ndSmAPred[i, r] = normal_rng(dSmHat[1],kappa[2]);\ndSmBPred[i, r] = normal_rng(dSmHat[2],kappa[2]);\ndSaAPred[i, r] = normal_rng(dSaHat[1],kappa[3]);\ndSaBPred[i, r] = normal_rng(dSaHat[2],kappa[3]);\n}\n}\n\nfor(r in 1:(maxR)){ \nfor(i in 1:nAnalytes){\npKawPred[i,r] = normal_rng(pKaslit[i,r], pKasliterror[i,r]);\netaStd1Pred[r,i] = normal_rng(0,1);\netaStd2Pred[r,i] = normal_rng(0,1);\n}\n}\n\nalpha1Pred = diag_pre_multiply(tau, L2 * etaStd1Pred)';\nalpha2Pred = diag_pre_multiply(tau, L2 * etaStd2Pred)';\n \nfor(i in 1:nAnalytes){\nfor(r in 1:maxR+1){\nlogkwxPred[i,r] = paramPred[i, 1] +\n    dlogkwAPred[i,r]*chargesA[i,r] +\n    dlogkwBPred[i,r]*chargesB[i,r];\nS1mxPred[i,r] = (paramPred[i, 2] + \n    dSmAPred[i,r]*chargesA[i,r] +\n    dSmBPred[i,r]*chargesB[i,r])*(1+S2mHat);\nS1axPred[i,r] = (paramPred[i, 3] + \n    dSaAPred[i,r]*chargesA[i,r] +\n    dSaBPred[i,r]*chargesB[i,r])*(1+S2aHat);\n}}\n\nfor(i in 1:nAnalytes){\nalphamPred[i,1] = (alphaAHat[1]+alpha1Pred[i,1]) * groupsA[i,1] + (alphaBHat[1]+alpha1Pred[i,1]) * groupsB[i,1];\nalphamPred[i,2] = (alphaAHat[1]+alpha2Pred[i,1]) * groupsA[i,2] + (alphaBHat[1]+alpha2Pred[i,1]) * groupsB[i,2];\n\nalphaaPred[i,1] = (alphaAHat[2]+alpha1Pred[i,2]) * groupsA[i,1] + (alphaBHat[2]+alpha1Pred[i,2]) * groupsB[i,1];\nalphaaPred[i,2] = (alphaAHat[2]+alpha2Pred[i,2]) * groupsA[i,2] + (alphaBHat[2]+alpha2Pred[i,2]) * groupsB[i,2];\n}\n\n// COND\n for(z in 1:nObs){\n\nif (mod[z]==1) {\ny_hat_Cond = chromgratrapz(steps[z], \n    logkwx[analyte[z],] +  dlogkT[analyte[z]]*hplcparam[z,11], \n    S1mx[analyte[z],],  \n    pKaw[analyte[z],], \n    alpham[analyte[z],],\n    S2mHat,\n    apH,\n    chargesA[analyte[z],],\n    chargesB[analyte[z],],\n    R[analyte[z]],\n    hplcparam[z]);\n}\n\nif (mod[z]==2) {\ny_hat_Cond = chromgratrapz(steps[z], \n    logkwx[analyte[z],] + dlogkT[analyte[z]]*hplcparam[z,11], \n    S1ax[analyte[z],],  \n    pKaw[analyte[z],], \n    alphaa[analyte[z],],\n    S2aHat,\n    apH,\n    chargesA[analyte[z],],\n    chargesB[analyte[z],],\n    R[analyte[z]],\n    hplcparam[z]);\n}\n\nreal trHatCond = hplcparam[z,3] + hplcparam[z,4] + y_hat_Cond; \ntrCond[z] = student_t_rng(3,trHatCond, sigma[analyte[z]]);\n}\n\n// PRED\nfor(z in 1:nObs){\nif (mod[z]==1) {\ny_hat_Pred = chromgratrapz(steps[z], \n       logkwxPred[analyte[z],] +  dlogkTPred[analyte[z]]*hplcparam[z,11], \n       S1mxPred[analyte[z],],  \n       pKawPred[analyte[z],], \n       alphamPred[analyte[z],],\n       S2mHat,\n       apH,\n       chargesA[analyte[z],],\n       chargesB[analyte[z],],\n       R[analyte[z]],\n       hplcparam[z]);\n}\n\nif (mod[z]==2) {\ny_hat_Pred = chromgratrapz(steps[z], \n       logkwxPred[analyte[z],]  + dlogkTPred[analyte[z]]*hplcparam[z,11], \n       S1axPred[analyte[z],],  \n       pKawPred[analyte[z],], \n       alphaaPred[analyte[z],],\n       S2aHat,\n       apH,\n       chargesA[analyte[z],],\n       chargesB[analyte[z],],\n       R[analyte[z]],\n       hplcparam[z]);\n}\n\n  real trHatPred = hplcparam[z,3] + hplcparam[z,4] + y_hat_Pred; \n\n  trPred[z] = student_t_rng(3, trHatPred, sigmaPred[analyte[z]]);\n}\n}"
  },
  {
    "objectID": "Model_1_b.html",
    "href": "Model_1_b.html",
    "title": "2  Estimated parameters",
    "section": "",
    "text": "Warning: 4000 of 4000 (100.0%) transitions hit the maximum treedepth limit of 10.\nSee https://mc-stan.org/misc/warnings for details.\n\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\n\n     variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwHat      3.57   3.57 0.07 0.07  3.45  3.68 1.00     1148     2203\n S1mHat        4.83   4.83 0.08 0.08  4.70  4.95 1.00     1462     2573\n S1aHat        5.96   5.95 0.11 0.12  5.77  6.15 1.01     1104     1816\n dlogkwHat[1] -0.75  -0.75 0.06 0.06 -0.85 -0.65 1.01      713     1217\n dlogkwHat[2] -0.98  -0.98 0.05 0.05 -1.06 -0.91 1.01      491     1576\n dSmHat[1]     0.25   0.25 0.09 0.10  0.10  0.39 1.04      175      673\n dSmHat[2]    -0.06  -0.06 0.07 0.07 -0.17  0.06 1.02      158      600\n dSaHat[1]     0.81   0.81 0.09 0.09  0.66  0.96 1.03      205      539\n dSaHat[2]    -0.57  -0.57 0.07 0.07 -0.67 -0.45 1.02      170      647\n S2mHat        0.49   0.49 0.03 0.03  0.44  0.53 1.04       95      369\n S2aHat        0.97   0.97 0.04 0.04  0.90  1.03 1.04      110      394\n beta[1]       0.82   0.82 0.03 0.03  0.77  0.88 1.00     1586     3003\n beta[2]       0.46   0.46 0.04 0.04  0.39  0.53 1.01      562     1863\n beta[3]       0.51   0.51 0.06 0.06  0.41  0.61 1.01      688     2049\n alphaAHat[1]  1.99   1.99 0.16 0.16  1.73  2.26 1.00      841     1702\n alphaAHat[2]  2.18   2.17 0.18 0.18  1.88  2.47 1.00     1681     2257\n alphaBHat[1] -1.04  -1.04 0.14 0.14 -1.26 -0.81 1.00      695     1365\n alphaBHat[2] -0.91  -0.90 0.16 0.16 -1.17 -0.64 1.00      959     1400\n dlogkTHat    -0.09  -0.09 0.00 0.00 -0.10 -0.09 1.00     4739     3332\n omegadlogkT   0.03   0.03 0.00 0.00  0.03  0.04 1.00     3041     2976\n apH[1]       -0.02  -0.02 0.00 0.00 -0.03 -0.02 1.00     3096     3672\n apH[2]        0.09   0.09 0.00 0.00  0.08  0.09 1.00     2446     2977\n msigma        0.36   0.36 0.03 0.03  0.32  0.41 1.00     8052     2773\n ssigma        1.00   1.00 0.05 0.05  0.92  1.09 1.00     7190     2749\n omega[1]      0.92   0.92 0.05 0.05  0.85  1.00 1.00     1629     2521\n omega[2]      0.95   0.95 0.05 0.05  0.86  1.04 1.00     1283     2329\n omega[3]      1.43   1.43 0.08 0.08  1.31  1.57 1.01      845     2253\n rho1[1,1]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho1[2,1]     0.87   0.87 0.02 0.02  0.83  0.90 1.01      540     2142\n rho1[3,1]     0.77   0.77 0.03 0.03  0.71  0.82 1.02      556     2801\n rho1[1,2]     0.87   0.87 0.02 0.02  0.83  0.90 1.01      540     2142\n rho1[2,2]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho1[3,2]     0.91   0.91 0.02 0.02  0.89  0.93 1.00     1420     2118\n rho1[1,3]     0.77   0.77 0.03 0.03  0.71  0.82 1.02      556     2801\n rho1[2,3]     0.91   0.91 0.02 0.02  0.89  0.93 1.00     1420     2118\n rho1[3,3]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n L2[1,1]       1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n L2[2,1]       0.94   0.94 0.02 0.02  0.91  0.96 1.01      529     1237\n L2[1,2]       0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n L2[2,2]       0.34   0.34 0.05 0.05  0.27  0.42 1.01      529     1237\n kappa[1]      0.53   0.53 0.03 0.03  0.49  0.58 1.01      457      969\n kappa[2]      0.50   0.50 0.04 0.04  0.44  0.57 1.02      201      512\n kappa[3]      0.51   0.51 0.04 0.04  0.44  0.59 1.05      130      213\n tau[1]        2.13   2.13 0.15 0.16  1.89  2.40 1.03      152     1311\n tau[2]        2.57   2.56 0.19 0.19  2.26  2.89 1.04      127     1015"
  },
  {
    "objectID": "Model_1_b.html#column-xterra-c18",
    "href": "Model_1_b.html#column-xterra-c18",
    "title": "2  Estimated parameters",
    "section": "2.2 Column XTerra C18",
    "text": "2.2 Column XTerra C18\n\n\nWarning: 3291 of 4000 (82.0%) transitions hit the maximum treedepth limit of 10.\nSee https://mc-stan.org/misc/warnings for details.\n\n\nWarning: 1 of 4 chains had an E-BFMI less than 0.2.\nSee https://mc-stan.org/misc/warnings for details.\n\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\n\n     variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwHat      3.83   3.83 0.10 0.10  3.66  4.00 1.00      928     2310\n S1mHat        5.00   5.00 0.11 0.11  4.82  5.18 1.00     1629     2186\n S1aHat        5.79   5.79 0.13 0.13  5.57  6.01 1.00     1315     2177\n dlogkwHat[1] -0.81  -0.81 0.07 0.07 -0.92 -0.70 1.00      698     1466\n dlogkwHat[2] -1.02  -1.02 0.05 0.05 -1.10 -0.93 1.00      711     1943\n dSmHat[1]     0.01   0.01 0.10 0.10 -0.16  0.17 1.03      166      472\n dSmHat[2]     0.23   0.23 0.08 0.08  0.10  0.36 1.02      178      393\n dSaHat[1]     0.48   0.49 0.10 0.10  0.30  0.64 1.03      135      311\n dSaHat[2]    -0.11  -0.11 0.08 0.08 -0.24  0.01 1.02      150      175\n S2mHat        0.73   0.73 0.04 0.04  0.66  0.80 1.02      152      439\n S2aHat        1.51   1.51 0.06 0.06  1.41  1.62 1.02      151      379\n beta[1]       0.82   0.82 0.04 0.04  0.76  0.88 1.00     1033     2436\n beta[2]       0.47   0.47 0.04 0.04  0.40  0.54 1.01      543     1942\n beta[3]       0.52   0.52 0.05 0.05  0.43  0.60 1.00      669     1353\n alphaAHat[1]  2.06   2.05 0.16 0.16  1.79  2.33 1.00     1967     2502\n alphaAHat[2]  2.15   2.15 0.20 0.20  1.82  2.48 1.00     3633     2870\n alphaBHat[1] -1.08  -1.08 0.13 0.14 -1.30 -0.86 1.02      661     1539\n alphaBHat[2] -1.11  -1.11 0.18 0.18 -1.40 -0.82 1.01     1261     2469\n dlogkTHat    -0.11  -0.11 0.00 0.00 -0.11 -0.10 1.00     5832     2865\n omegadlogkT   0.04   0.04 0.00 0.00  0.03  0.04 1.00     3965     3107\n apH[1]       -0.04  -0.04 0.00 0.00 -0.04 -0.04 1.00     2661     3582\n apH[2]        0.05   0.05 0.00 0.00  0.05  0.05 1.00     2690     3223\n msigma        0.49   0.49 0.03 0.03  0.44  0.54 1.00     7293     2840\n ssigma        0.88   0.88 0.05 0.05  0.81  0.96 1.00     6249     2734\n omega[1]      0.69   0.69 0.05 0.05  0.62  0.77 1.00     1510     2705\n omega[2]      0.70   0.70 0.05 0.05  0.62  0.79 1.00     1388     2353\n omega[3]      0.88   0.88 0.06 0.06  0.78  1.00 1.00     1353     2261\n rho1[1,1]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho1[2,1]     0.79   0.79 0.04 0.04  0.71  0.85 1.01      850     2241\n rho1[3,1]     0.77   0.78 0.04 0.04  0.71  0.83 1.00     1082     2650\n rho1[1,2]     0.79   0.79 0.04 0.04  0.71  0.85 1.01      850     2241\n rho1[2,2]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho1[3,2]     0.89   0.89 0.02 0.02  0.85  0.92 1.00     1486     2430\n rho1[1,3]     0.77   0.78 0.04 0.04  0.71  0.83 1.00     1082     2650\n rho1[2,3]     0.89   0.89 0.02 0.02  0.85  0.92 1.00     1486     2430\n rho1[3,3]     1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n L2[1,1]       1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n L2[2,1]       0.90   0.90 0.02 0.02  0.86  0.93 1.00     1035     2251\n L2[1,2]       0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n L2[2,2]       0.43   0.43 0.05 0.05  0.36  0.51 1.00     1035     2251\n kappa[1]      0.57   0.57 0.03 0.03  0.51  0.62 1.01      396      818\n kappa[2]      0.50   0.50 0.04 0.04  0.43  0.58 1.02      178      342\n kappa[3]      0.45   0.44 0.04 0.04  0.38  0.53 1.04      105      275\n tau[1]        2.01   2.00 0.16 0.16  1.75  2.29 1.10       25      165\n tau[2]        2.97   2.97 0.21 0.21  2.64  3.31 1.03      303     1897"
  },
  {
    "objectID": "Model_2.html",
    "href": "Model_2.html",
    "title": "Model 2",
    "section": "",
    "text": "In the model, all parameters (except for the pKa of the compounds) were duplicated to investigate the inter-column variability."
  },
  {
    "objectID": "Model_2_a.html",
    "href": "Model_2_a.html",
    "title": "5  Stan code",
    "section": "",
    "text": "functions {\n\n// credit http://srmart.in/informative-priors-for-correlation-matrices-an-easy-approach/\nvector lower_tri(matrix mat) {\n\nint d = rows(mat);\nint lower_tri_d = d * (d - 1) / 2;\nvector[lower_tri_d] lower;\nint count = 1;\nfor(r in 2:d) {\nfor(c in 1:(r - 1)) {\nlower[count] = mat[r,c];\ncount += 1;\n}\n}\nreturn(lower); \n}\n\n// credit http://srmart.in/informative-priors-for-correlation-matrices-an-easy-approach/\nreal lkj_corr_point_lower_tri_lpdf(matrix rho, vector point_mu_lower, vector point_scale_lower) {\n\nreal lpdf = lkj_corr_lpdf(rho | 1) + normal_lpdf(lower_tri(rho) | point_mu_lower, point_scale_lower);\nreturn(lpdf);\n}\n\n\nreal lkj_corr_cholesky_point_lower_tri_two_lpdf(matrix cor_L, real point_mu_lower, real point_scale_lower) {\n    real lpdf = lkj_corr_cholesky_lpdf(cor_L | 1);\n    int d = rows(cor_L);\n    matrix[d,d] cor = multiply_lower_tri_self_transpose(cor_L);\n    lpdf += normal_lpdf(cor[2,1] | point_mu_lower, point_scale_lower);\n    return(lpdf);\n  }\n\n// pH and fi at a given time at column inlet\nvector gra_state(real t,  vector hplcparam) {\n\nvector[2] sol;\nreal tg = hplcparam[1];\nreal td = hplcparam[2];\nreal fio = hplcparam[5];\nreal fik = hplcparam[6];\nreal pHo = hplcparam[8];\nreal alpha1 = hplcparam[9];\nreal alpha2 = hplcparam[10];\nreal fi;\n\nfi = fio+(fik-fio)/tg*(t-td);\n\nif (t<td)\nfi = fio;\nelse if (t>tg+td)\nfi = fik;\n\nsol[1]=fi;\nsol[2]=pHo+alpha1*fi+alpha2*fi^2;\n\nreturn sol;\n}\n\nreal funlogki(vector logkwx, vector S1, vector pKaw, vector alpha, real S2, vector apH,\n              int nDiss, vector chargesA, vector chargesB, vector fipH) {\n\nreal logki;\nvector[3] logkix;\nvector[2] pHmpKa;\nreal fi=fipH[1];\nreal pH=fipH[2];\n\nlogkix=logkwx-S1*fi/(1+S2*fi)+ chargesA*apH[1]*(pH-7) + chargesB*apH[2]*(pH-7);\npHmpKa=pH-(pKaw+alpha*fi);\n\nif (nDiss==0) {\n    logki = logkix[1]; \n}\nelse if (nDiss==1){\n    logki=logkix[1] +\n    log1p_exp(log(10)*(pHmpKa[1]+logkix[2]-logkix[1]))/log(10)-\n    log1p_exp(log(10)*(pHmpKa[1]))/log(10);\n}\nelse if (nDiss==2){\n    logki = logkix[1] +\n    log1p_exp(log(10)*(pHmpKa[1]+logkix[2]-logkix[1]) + \n    log1p_exp(log(10)*(pHmpKa[2]+logkix[3]-logkix[2])))/log(10)-\n    log1p_exp(log(10)*(pHmpKa[1]) + \n    log1p_exp(log(10)*(pHmpKa[2])))/log(10);\n}\n\nreturn logki;\n}\n\nvector areaandslope(real time1, real time2, real invki1, real invki2) {\n\nvector[2] cki_b;\nreal bo;\nreal cki;\n\nif (invki2>1.001*invki1) {\n    bo = (log(invki2)-log(invki1))/(time2-time1);\n    cki = (invki2-invki1)/bo;\n}\nelse {\n    bo  = 0.001/(time2-time1);\n    cki = (time2-time1)*(invki2+invki1)/2;\n}\n\ncki_b[1] = cki;\ncki_b[2] = bo;\n\nreturn cki_b;\n}\n\nreal chromgratrapz(int steps, \n           vector logkwx, vector logkmx, vector pKaw, vector alpha,\n           real S2, vector apH, vector chargesA, vector chargesB,\n           int nDiss, vector hplcparam) {\n\nreal tg = hplcparam[1];\nreal td = hplcparam[2];\nreal to = hplcparam[3];\n\nvector[1] sol;\nreal time1;\nreal time2; \nvector[2] fipH1;\nvector[2] fipH2;\nreal logki1;\nreal logki2; \nreal invki1;\nreal invki2;\nvector[2] cki_b;\nreal cumki1;\nreal cumki2;\nreal bo;\nreal tr;\nreal dt;\n\ndt = tg/steps;\n\ntime1 = 0;\ntime2 = td;\n\nfipH1 = gra_state(time1,  hplcparam);\n// fipH2 = fipH1;\n\nlogki1 = funlogki(logkwx, logkmx, pKaw, alpha, S2, apH, nDiss, chargesA, chargesB, fipH1);\n//logki2 = logki1;\n\ninvki1 = 1/to/10^logki1;\ninvki2 = invki1;\n\ncumki1 = 0;\ncumki2 = td*invki1; // cumulative area\n\nbo     = 0.001/td;  // slope\n\nfor(x in 1:steps){ \n    if (cumki2>=1)  continue;\n    time1 = time2;\n    time2 += dt;\n//    fipH1 = fipH2;\n    fipH2 = gra_state(time2,  hplcparam);\n//    logki1 = logki2;\n    logki2 = funlogki(logkwx, logkmx, pKaw, alpha, S2, apH, nDiss, chargesA, chargesB, fipH2);\n    invki1 = invki2;\n    invki2 = 1/to/10^logki2;\n    cki_b = areaandslope(time1, time2, invki1, invki2);\n    cumki1 = cumki2;\n    cumki2 += cki_b[1]; // cumulative area\n    bo      = cki_b[2]; //slope\n}\n\nif (cumki2>=1) {\n    tr = time1+log1p((1-cumki1)*bo/invki1)/bo;\n}\nelse if (cumki2<1) {\n    tr = time2+(1-cumki2)/invki2;\n}\n\nreturn tr;\n}\n\nreal partial_sum(int[] ind, int start, int end, vector trObs, \nint[] mod, int[] steps, int[] analyte, int[] pHid,\nvector[] hplcparam, vector[] chargesA, vector[] chargesB, int[] nDiss,\nvector[] logkwx, vector dlogkT, vector[] S1mx, vector[] S1ax,\nvector[] pKaw, vector[] alpham, vector[] alphaa,\nreal S2m, real S2a,\nvector apH,\nvector sigma) {\n\nreal lp = 0;\nreal y_hat;\n\nfor(z in start:end){\n\nif (mod[z]==1) {\ny_hat = chromgratrapz(steps[z], \n       logkwx[analyte[z],] + dlogkT[analyte[z]]*hplcparam[z,11], \n       S1mx[analyte[z],],  \n       pKaw[analyte[z],], \n       alpham[analyte[z],],\n       S2m,\n       apH,\n       chargesA[analyte[z],], \n       chargesB[analyte[z],], \n       nDiss[analyte[z]],\n       hplcparam[z]);\n }\n\nif (mod[z]==2) {\ny_hat = chromgratrapz(steps[z], \n       logkwx[analyte[z],]  + dlogkT[analyte[z]]*hplcparam[z,11], \n       S1ax[analyte[z],],  \n       pKaw[analyte[z],], \n       alphaa[analyte[z],],\n       S2a,\n       apH,\n       chargesA[analyte[z],],\n       chargesB[analyte[z],], \n       nDiss[analyte[z]],\n       hplcparam[z]);\n}\n\n  real trHat = hplcparam[z,3] + hplcparam[z,4] + y_hat; \n\n  lp = lp + student_t_lpdf(trObs[z] | 3, trHat, sigma[analyte[z]]);\n\n }\n return lp;\n}\n}\n\ndata{\nint nAnalytes1;            // number of analytes\nint nObs1;                 // number of observations\nint npH;                   // npH;\nint analyte1[nObs1];           // analyte indexes\nint pHid1[nObs1];\nint<lower=1> steps1[nObs1];   // steps for gradient retention time aproimation\nvector[11] hplcparam1[nObs1]; // [tg, td, to, te, fio, fik, mod, pHo, alpha1, alpha2, (temp-25)/10]\nint<lower=0> mod1[nObs1];     // MeOH==1, ACN==2 (repeats hplcparam(:,7))\n\nvector[nAnalytes1] logPobs1; \n\nint<lower=0,upper=2> maxR;\nint<lower=0,upper=2> R1[nAnalytes1];\nordered[maxR] pKaslit1[nAnalytes1];\nvector[maxR] pKasliterror1[nAnalytes1];\nvector[maxR] groupsA1[nAnalytes1];\nvector[maxR] groupsB1[nAnalytes1];\nvector[maxR+1] chargesA1[nAnalytes1];\nvector[maxR+1] chargesB1[nAnalytes1];\n\nint<lower=0> K;                      //  number of predictors (functional groups)\nmatrix[nAnalytes1, K] nrfungroups1;   // predictor matrix (functional groups)   \n\nvector[nObs1] trobs1; // observed retention factors \n\nint nAnalytes2;            // number of analytes\nint nObs2;                 // number of observations\nint analyte2[nObs2];           // analyte indexes\nint pHid2[nObs2];\nint<lower=1> steps2[nObs2];   // steps for gradient retention time aproimation\nvector[11] hplcparam2[nObs2]; // [tg, td, to, te, fio, fik, mod, pHo, alpha1, alpha2, (temp-25)/10]\nint<lower=0> mod2[nObs2];     // MeOH==1, ACN==2 (repeats hplcparam(:,7))\n\nvector[nAnalytes2] logPobs2; \n\nint<lower=0,upper=2> R2[nAnalytes2];\nordered[maxR] pKaslit2[nAnalytes2];\nvector[maxR] pKasliterror2[nAnalytes2];\nvector[maxR] groupsA2[nAnalytes2];\nvector[maxR] groupsB2[nAnalytes2];\nvector[maxR+1] chargesA2[nAnalytes2];\nvector[maxR+1] chargesB2[nAnalytes2];\n                  //  number of predictors (functional groups)\nmatrix[nAnalytes2, K] nrfungroups2;   // predictor matrix (functional groups)   \n\nvector[nObs2] trobs2; // observed retention factors \n}\n\ntransformed data {\nint grainsize = 1;\nint ind1[nObs1] = rep_array(1, nObs1);\nint ind2[nObs2] = rep_array(1, nObs2);\nvector[3] point_mu_lower = [0.75,0.75,0.75]';       // mean priors for rho\nvector[3] point_scale_lower = [0.125,0.125,0.125]'; // std priors for rho\n}\n\nparameters{\nreal logkwHat1;        // typical value of logkw [N]\nreal S1mHat1;          // typical value of S1m [N]\nreal S1aHat1;           // typical value of S1a [N]\nreal dlogkwHat1[2];     // typical value of dlogkw [A,B] \nreal dSmHat1[2];        // typical value of dlogkm [A,B] \nreal dSaHat1[2];        // typical value of dlogka [A,B] \nreal<lower = 0> S2mHat1; // typical value of S2m \nreal<lower = 0> S2aHat1; // typical value of S2a\nvector[3] beta1;         // effects of logP \nreal dlogkTHat1;         // typical dlogkT\nvector[2] alphaAHat1;  // changes of pKa with org. mod for acids [MeOH, ACN]\nvector[2] alphaBHat1;  // changes of pKa with org. mod for bases [MeOH, ACN]\n\nvector<lower = 0.01>[3] omega1;   // between analyte variabilities (neutral forms)\ncorr_matrix[3] rho11;                           // correlation matrix    \nvector<lower = 0.01>[3] kappa1;    // between analyte variabilities (diss. forms)\nvector<lower = 0.01>[2] tau;     // between analyte variabilities for acids pKa\ncholesky_factor_corr[2] L2;                         // cholesky \nreal<lower = 0.01, upper = 1> omegadlogkT1;  // between analyte variability for temperature\n\n// between buffer differences\nvector[2] apH1; // pH effects\n\nvector[K] pilogkw1;  // regression coefficient for logkw\nvector[K] piS1m1;  // regression coefficient for S1m\nvector[K] piS1a1;  // regression coefficient for S1a\n\nvector<lower = 0.01>[3] sdpi1;     // between analyte variabilities for acids pKa\n\n// residual variability\nreal<lower = 0.01> msigma1; // mean\nreal<lower = 0.01> ssigma1; // scale\n\n\nreal logkwHat2;        // typical value of logkw [N]\nreal S1mHat2;          // typical value of S1m [N]\nreal S1aHat2;           // typical value of S1a [N]\nreal dlogkwHat2[2];     // typical value of dlogkw [A,B] \nreal dSmHat2[2];        // typical value of dlogkm [A,B] \nreal dSaHat2[2];        // typical value of dlogka [A,B] \nreal<lower = 0> S2mHat2; // typical value of S2m \nreal<lower = 0> S2aHat2; // typical value of S2a\nvector[3] beta2;         // effects of logP \nreal dlogkTHat2;         // typical dlogkT\nvector[2] alphaAHat2;  // changes of pKa with org. mod for acids [MeOH, ACN]\nvector[2] alphaBHat2;  // changes of pKa with org. mod for bases [MeOH, ACN]\n\nvector<lower = 0.01>[3] omega2;   // between analyte variabilities (neutral forms)\ncorr_matrix[3] rho12;                           // correlation matrix    \nvector<lower = 0.01>[3] kappa2;    // between analyte variabilities (diss. forms)\nreal<lower = 0.01, upper = 1> omegadlogkT2;  // between analyte variability for temperature\n\n// between buffer differences\nvector[2] apH2; // pH effects\n\nvector[K] pilogkw2;  // regression coefficient for logkw\nvector[K] piS1m2;  // regression coefficient for S1m\nvector[K] piS1a2;  // regression coefficient for S1a\n\nvector<lower = 0.01>[3] sdpi2;     // between analyte variabilities for acids pKa\n\n// residual variability\nreal<lower = 0.01> msigma2; // mean\nreal<lower = 0.01> ssigma2; // scale\n\n// individual values of chromatographic parameters\nvector[3] param1[nAnalytes1]; \nvector[nAnalytes1] dlogkT1; \nmatrix[nAnalytes1,maxR+1] dlogkwA1;\nmatrix[nAnalytes1,maxR+1] dlogkwB1;\nmatrix[nAnalytes1,maxR+1] dSmA1;\nmatrix[nAnalytes1,maxR+1] dSmB1;\nmatrix[nAnalytes1,maxR+1] dSaA1;\nmatrix[nAnalytes1,maxR+1] dSaB1;\n\nvector[maxR] pKaw1[nAnalytes1];\nmatrix[maxR,nAnalytes1] etaStd11;\nmatrix[maxR,nAnalytes1] etaStd21;\n\nvector[3] param2[nAnalytes2]; \nvector[nAnalytes2] dlogkT2; \nmatrix[nAnalytes2,maxR+1] dlogkwA2;\nmatrix[nAnalytes2,maxR+1] dlogkwB2;\nmatrix[nAnalytes2,maxR+1] dSmA2;\nmatrix[nAnalytes2,maxR+1] dSmB2;\nmatrix[nAnalytes2,maxR+1] dSaA2;\nmatrix[nAnalytes2,maxR+1] dSaB2;\n\nvector[maxR] pKaw2[nAnalytes2];\nmatrix[maxR,nAnalytes2] etaStd12;\nmatrix[maxR,nAnalytes2] etaStd22;\n// and residuals\nvector<lower = 0.01, upper = 4>[nAnalytes1] sigma1;\nvector<lower = 0.01, upper = 4>[nAnalytes2] sigma2;\n}\n\ntransformed parameters{\nvector[maxR+1] logkwx1[nAnalytes1];\nvector[maxR+1] S1mx1[nAnalytes1];\nvector[maxR+1] S1ax1[nAnalytes1];\nmatrix[nAnalytes1,maxR] alpha11;   //MeOH or ACN\nmatrix[nAnalytes1,maxR] alpha21;   //MeOH or ACN\n\nvector[maxR] alpham1[nAnalytes1];\nvector[maxR] alphaa1[nAnalytes1];\n\nvector[3] miu1[nAnalytes1]; \n\nvector[maxR+1] logkwx2[nAnalytes2];\nvector[maxR+1] S1mx2[nAnalytes2];\nvector[maxR+1] S1ax2[nAnalytes2];\nmatrix[nAnalytes2,maxR] alpha12;   //MeOH or ACN\nmatrix[nAnalytes2,maxR] alpha22;   //MeOH or ACN\n\nvector[maxR] alpham2[nAnalytes2];\nvector[maxR] alphaa2[nAnalytes2];\n\nvector[3] miu2[nAnalytes2]; \n\ncov_matrix[3] Omega1; // variance-covariance matrix\n\nOmega1 = quad_form_diag(rho11, omega1); // diag_matrix(omega) * rho * diag_matrix(omega)\n\ncov_matrix[3] Omega2; // variance-covariance matrix\n\nOmega2 = quad_form_diag(rho12, omega2); // diag_matrix(omega) * rho * diag_matrix(omega)\n\n// Matt's trick to use unit scale \n alpha11 = diag_pre_multiply(tau, L2 * etaStd11)';\n alpha21 = diag_pre_multiply(tau, L2 * etaStd21)';\n alpha12 = diag_pre_multiply(tau, L2 * etaStd12)';\n alpha22 = diag_pre_multiply(tau, L2 * etaStd22)';\n\nfor(i in 1:nAnalytes1){\n    miu1[i,1]  = logkwHat1 + beta1[1] * (logPobs1[i]-2.2) + nrfungroups1[i] * pilogkw1;\n    miu1[i,2]  = S1mHat1   + beta1[2] * (logPobs1[i]-2.2) + nrfungroups1[i] * piS1m1; \n    miu1[i,3]  = S1aHat1   + beta1[3] * (logPobs1[i]-2.2) + nrfungroups1[i] * piS1a1;\n}\n\nfor(i in 1:nAnalytes2){\n    miu2[i,1]  = logkwHat2 + beta2[1] * (logPobs2[i]-2.2) + nrfungroups2[i] * pilogkw2;\n    miu2[i,2]  = S1mHat2   + beta2[2] * (logPobs2[i]-2.2) + nrfungroups2[i] * piS1m2; \n    miu2[i,3]  = S1aHat2   + beta2[3] * (logPobs2[i]-2.2) + nrfungroups2[i] * piS1a2;\n}\n\nfor(i in 1:nAnalytes1){\nfor(r in 1:maxR+1){\nlogkwx1[i,r] = param1[i, 1] +\n            dlogkwA1[i,r]*chargesA1[i,r] +\n            dlogkwB1[i,r]*chargesB1[i,r];\nS1mx1[i,r] = (param1[i, 2] + \n            dSmA1[i,r]*chargesA1[i,r] +\n            dSmB1[i,r]*chargesB1[i,r])*(1+(S2mHat1));\nS1ax1[i,r] = (param1[i, 3] + \n            dSaA1[i,r]*chargesA1[i,r] +\n            dSaB1[i,r]*chargesB1[i,r])*(1+(S2aHat1));\n\n}}\n\nfor(i in 1:nAnalytes2){\nfor(r in 1:maxR+1){\nlogkwx2[i,r] = param2[i, 1] +\n            dlogkwA2[i,r]*chargesA2[i,r] +\n            dlogkwB2[i,r]*chargesB2[i,r];\nS1mx2[i,r] = (param2[i, 2] + \n            dSmA2[i,r]*chargesA2[i,r] +\n            dSmB2[i,r]*chargesB2[i,r])*(1+(S2mHat2));\nS1ax2[i,r] = (param2[i, 3] + \n            dSaA2[i,r]*chargesA2[i,r] +\n            dSaB2[i,r]*chargesB2[i,r])*(1+(S2aHat2));\n\n}}\n\nfor(i in 1:nAnalytes1){\nalpham1[i,1] = (alphaAHat1[1]+alpha11[i,1]) * groupsA1[i,1] + (alphaBHat1[1]+alpha11[i,1]) * groupsB1[i,1];\nalpham1[i,2] = (alphaAHat1[1]+alpha21[i,1]) * groupsA1[i,2] + (alphaBHat1[1]+alpha21[i,1]) * groupsB1[i,2];\n\nalphaa1[i,1] = (alphaAHat1[2]+alpha11[i,2]) * groupsA1[i,1] + (alphaBHat1[2]+alpha11[i,2]) * groupsB1[i,1];\nalphaa1[i,2] = (alphaAHat1[2]+alpha21[i,2]) * groupsA1[i,2] + (alphaBHat1[2]+alpha21[i,2]) * groupsB1[i,2];\n}\n\nfor(i in 1:nAnalytes2){\nalpham2[i,1] = (alphaAHat2[1]+alpha12[i,1]) * groupsA2[i,1] + (alphaBHat2[1]+alpha12[i,1]) * groupsB2[i,1];\nalpham2[i,2] = (alphaAHat2[1]+alpha22[i,1]) * groupsA2[i,2] + (alphaBHat2[1]+alpha22[i,1]) * groupsB2[i,2];\n\nalphaa2[i,1] = (alphaAHat2[2]+alpha12[i,2]) * groupsA2[i,1] + (alphaBHat2[2]+alpha12[i,2]) * groupsB2[i,1];\nalphaa2[i,2] = (alphaAHat2[2]+alpha22[i,2]) * groupsA2[i,2] + (alphaBHat2[2]+alpha22[i,2]) * groupsB2[i,2];\n}\n\n}\nmodel{\nlogkwHat1  ~ normal(2.2, 2);\nS1mHat1    ~ normal(4, 1);\nS1aHat1    ~ normal(5, 1);\ndlogkwHat1 ~ normal(-1,0.125);\ndSmHat1    ~ normal(0,0.5);\ndSaHat1    ~ normal(0,0.5);\nS2mHat1    ~ lognormal(-1.6,0.125);\nS2aHat1    ~ lognormal(0.69,0.125);\nalphaAHat1 ~ normal(2,0.25);\nalphaBHat1 ~ normal(-1,0.25);\nbeta1[{1}] ~ normal(1,0.125);\nbeta1[{2,3}] ~ normal(0.5,0.5);\nomega1       ~ normal(0,2);\nrho11         ~ lkj_corr_point_lower_tri(point_mu_lower, point_scale_lower);\nkappa1       ~ normal(0,0.5);\n\napH1 ~ normal(0,0.1);\n\npilogkw1 ~ normal(0,sdpi1[1]);\npiS1m1   ~ normal(0,sdpi1[2]);\npiS1a1   ~ normal(0,sdpi1[3]);\n\nsdpi1 ~ normal(0,0.1);\n\nlogkwHat2  ~ normal(2.2, 2);\nS1mHat2    ~ normal(4, 1);\nS1aHat2    ~ normal(5, 1);\ndlogkwHat2 ~ normal(-1,0.125);\ndSmHat2    ~ normal(0,0.5);\ndSaHat2    ~ normal(0,0.5);\nS2mHat2    ~ lognormal(-1.6,0.125);\nS2aHat2    ~ lognormal(0.69,0.125);\nalphaAHat2 ~ normal(2,0.25);\nalphaBHat2 ~ normal(-1,0.25);\nbeta2[{1}] ~ normal(1,0.125);\nbeta2[{2,3}] ~ normal(0.5,0.5);\nomega2       ~ normal(0,2);\nrho12         ~ lkj_corr_point_lower_tri(point_mu_lower, point_scale_lower);\nkappa2       ~ normal(0,0.5);\n\napH2 ~ normal(0,0.1);\n\npilogkw2 ~ normal(0,sdpi2[1]);\npiS1m2   ~ normal(0,sdpi2[2]);\npiS1a2   ~ normal(0,sdpi2[3]);\n\nsdpi2 ~ normal(0,0.1);\n\n\ntau ~ normal(0,0.5);\nL2 ~ lkj_corr_cholesky_point_lower_tri_two(0.75, 0.125);\n\ndlogkTHat1   ~ normal(-0.087,0.022);\nomegadlogkT1 ~ normal(0,0.022);\n\ndlogkTHat2   ~ normal(-0.087,0.022);\nomegadlogkT2 ~ normal(0,0.022);\n\n\nsigma1  ~ lognormal(log(msigma1),ssigma1); \nsigma2  ~ lognormal(log(msigma2),ssigma2); \n\nmsigma1 ~ normal(0,1);\nssigma1 ~ normal(0,1);\n\nmsigma2 ~ normal(0,1);\nssigma2 ~ normal(0,1);\n\nfor(i in  1:nAnalytes1){\nparam1[i] ~ multi_normal(miu1[i],Omega1);\n}\n\nfor(i in  1:nAnalytes2){\nparam2[i] ~ multi_normal(miu2[i],Omega2);\n}\n\nto_vector(dlogkwA1) ~ normal(dlogkwHat1[1],kappa1[1]);\nto_vector(dlogkwB1) ~ normal(dlogkwHat1[2],kappa1[1]);\nto_vector(dSmA1) ~ normal(dSmHat1[1],kappa1[2]);\nto_vector(dSmB1) ~ normal(dSmHat1[2],kappa1[2]);\nto_vector(dSaA1) ~ normal(dSaHat1[1],kappa1[3]);\nto_vector(dSaB1) ~ normal(dSaHat1[2],kappa1[3]);\n\nto_vector(etaStd11) ~ std_normal();\nto_vector(etaStd21) ~ std_normal();\n\ndlogkT1  ~ normal(dlogkTHat1,omegadlogkT1);\n\nto_vector(dlogkwA2) ~ normal(dlogkwHat2[1],kappa2[1]);\nto_vector(dlogkwB2) ~ normal(dlogkwHat2[2],kappa2[1]);\nto_vector(dSmA2) ~ normal(dSmHat2[1],kappa2[2]);\nto_vector(dSmB2) ~ normal(dSmHat2[2],kappa2[2]);\nto_vector(dSaA2) ~ normal(dSaHat2[1],kappa2[3]);\nto_vector(dSaB2) ~ normal(dSaHat2[2],kappa2[3]);\n\nto_vector(etaStd12) ~ std_normal();\nto_vector(etaStd22) ~ std_normal();\n\ndlogkT2  ~ normal(dlogkTHat2,omegadlogkT2);\n\nfor (i in 1:nAnalytes1) pKaw1[i] ~ normal(pKaslit1[i],pKasliterror1[i]);\nfor (i in 1:nAnalytes2) pKaw2[i] ~ normal(pKaslit2[i],pKasliterror2[i]);\n\ntarget += reduce_sum(partial_sum, ind1, grainsize, trobs1, \n        mod1, steps1, analyte1, pHid1, hplcparam1, chargesA1, chargesB1, R1,\n        logkwx1, dlogkT1, S1mx1, S1ax1,\n        pKaw1, alpham1, alphaa1,\n        S2mHat1, S2aHat1,\n        apH1, sigma1);\n        \ntarget += reduce_sum(partial_sum, ind2, grainsize, trobs2, \n        mod2, steps2, analyte2, pHid2, hplcparam2, chargesA2, chargesB2, R2,\n        logkwx2, dlogkT2, S1mx2, S1ax2,\n        pKaw2, alpham2, alphaa2,\n        S2mHat2, S2aHat2,\n        apH2, sigma2);        \n}\n\ngenerated quantities{\n\n}"
  }
]